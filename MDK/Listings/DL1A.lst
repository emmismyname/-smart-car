C251 COMPILER V5.60.0,  DL1A                                                               25/04/24  13:33:30  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE DL1A
OBJECT MODULE PLACED IN .\Out_flie\DL1A.obj
COMPILER INVOKED BY: D:\Keil_80251\C251\BIN\C251.EXE ..\LIB\peripheral\DL1A.c XSMALL INTR2 BROWSE INCDIR(..\LIB\startup;
                    -..\LIB\libraries;..\LIB\peripheral;..\USER\inc) DEBUG PRINT(.\Listings\DL1A.lst) TABS(2) OBJECT(.\Out_flie\DL1A.obj) 

stmt  level    source

    1          
    2          /********************************************************************************************************
             -*************
    3           * @file          æ¿€å…‰æµ‹è·æ¨¡å—DL1A
    4           * @date          2024-03-06
    5           * @note    
    6           * æ¥çº¿å®šä¹‰ï¼š
    7           *                   ------------------------------------
    8           *                   æ¨¡å—ç®¡è„š            å•ç‰‡æœºç®¡è„š
    9           *                   SCL                 æŸ¥çœ‹ DL1A.h ä¸­ DL1A_SCL_PIN   å®å®šä¹‰
   10           *                   SDA                 æŸ¥çœ‹ DL1A.h ä¸­ DL1A_SDA_PIN   å®å®šä¹‰
   11           *                   XS                  æŸ¥çœ‹ DL1A.h ä¸­ DL1A_XSHUT_PIN å®å®šä¹‰
   12           *                   VCC                 5V ç”µæº
   13           *                   GND                 ç”µæºåœ°
   14           *                   ------------------------------------
   15          *********************************************************************************************************
             -***********/
   16          
   17          
   18          #include "delay.h"
   19          #include "DL1A.h"
   20          
   21          #pragma warning disable = 183
   22          
   23          
   24          uint8 dl1a_finsh_flag;
   25          uint16 dl1a_distance_mm;
   26          
   27          
   28          
   29          #define GET_DL1A_SDA            DL1A_SDA_PIN
   30          #define DL1A_SDA_LOW()          DL1A_SDA_PIN = 0    //IOå£è¾“å‡ºä½ç”µå¹³
   31          #define DL1A_SDA_HIGH()         DL1A_SDA_PIN = 1    //IOå£è¾“å‡ºé«˜ç”µå¹³
   32          
   33          #define DL1A_SCL_LOW()            DL1A_SCL_PIN = 0    //IOå£è¾“å‡ºä½ç”µå¹³
   34          #define DL1A_SCL_HIGH()           DL1A_SCL_PIN = 1    //IOå£è¾“å‡ºé«˜ç”µå¹³
   35          
   36          #define ack 1      //ä¸»åº”ç­”
   37          #define no_ack 0   //ä»åº”ç­”  
   38          
   39          //-------------------------------------------------------------------------------------------------------
             -------------
   40          //  @brief      æ¨¡æ‹ŸIICå»¶æ—¶
   41          //  @return     void            
   42          //  Sample usage:       å¦‚æœIICé€šè®¯å¤±è´¥å¯ä»¥å°è¯•å¢åŠ jçš„å€¼
   43          //-------------------------------------------------------------------------------------------------------
             -------------
   44          static void dl1a_simiic_delay(void)
   45          {
   46   1          uint16 j=DL1A_SOFT_IIC_DELAY;   
   47   1        while(j--);
   48   1      }
   49          
   50          //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
   51          static void dl1a_simiic_start(void)
   52          {
   53   1        DL1A_SDA_HIGH();
   54   1        DL1A_SCL_HIGH();
C251 COMPILER V5.60.0,  DL1A                                                               25/04/24  13:33:30  PAGE 2   

   55   1        dl1a_simiic_delay();
   56   1        DL1A_SDA_LOW();
   57   1        dl1a_simiic_delay();
   58   1        DL1A_SCL_LOW();
   59   1      }
   60          
   61          //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
   62          static void dl1a_simiic_stop(void)
   63          {
   64   1        DL1A_SDA_LOW();
   65   1        DL1A_SCL_LOW();
   66   1        dl1a_simiic_delay();
   67   1        DL1A_SCL_HIGH();
   68   1        dl1a_simiic_delay();
   69   1        DL1A_SDA_HIGH();
   70   1        dl1a_simiic_delay();
   71   1      }
   72          
   73          //ä¸»åº”ç­”(åŒ…å«ack:SDA=0å’Œno_ack:SDA=0)
   74          //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
   75          static void dl1a_simiic_sendack(unsigned char ack_dat)
   76          {
   77   1          DL1A_SCL_LOW();
   78   1        dl1a_simiic_delay();
   79   1        if(ack_dat) DL1A_SDA_LOW();
   80   1          else      DL1A_SDA_HIGH();
   81   1      
   82   1          DL1A_SCL_HIGH();
   83   1          dl1a_simiic_delay();
   84   1          DL1A_SCL_LOW();
   85   1          dl1a_simiic_delay();
   86   1      }
   87          
   88          
   89          static int dl1a_sccb_waitack(void)
   90          {
   91   1          DL1A_SCL_LOW();
   92   1      
   93   1        dl1a_simiic_delay();
   94   1        
   95   1        DL1A_SCL_HIGH();
   96   1          dl1a_simiic_delay();
   97   1        
   98   1          if(GET_DL1A_SDA)           //åº”ç­”ä¸ºé«˜ç”µå¹³ï¼Œå¼‚å¸¸ï¼Œé€šä¿¡å¤±è´¥
   99   1          {
  100   2      
  101   2              DL1A_SCL_LOW();
  102   2              return 0;
  103   2          }
  104   1      
  105   1          DL1A_SCL_LOW();
  106   1        dl1a_simiic_delay();
  107   1          return 1;
  108   1      }
  109          
  110          //å­—èŠ‚å‘é€ç¨‹åº
  111          //å‘é€c(å¯ä»¥æ˜¯æ•°æ®ä¹Ÿå¯æ˜¯åœ°å€)ï¼Œé€å®Œåæ¥æ”¶ä»åº”ç­”
  112          //ä¸è€ƒè™‘ä»åº”ç­”ä½
  113          //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
  114          static void dl1a_send_ch(uint8 c)
  115          {
  116   1        uint8 i = 8;
  117   1          while(i--)
  118   1          {
  119   2              if(c & 0x80)  DL1A_SDA_HIGH();//SDA è¾“å‡ºæ•°æ®
  120   2              else      DL1A_SDA_LOW();
C251 COMPILER V5.60.0,  DL1A                                                               25/04/24  13:33:30  PAGE 3   

  121   2              c <<= 1;
  122   2              dl1a_simiic_delay();
  123   2              DL1A_SCL_HIGH();                //SCL æ‹‰é«˜ï¼Œé‡‡é›†ä¿¡å·
  124   2              dl1a_simiic_delay();
  125   2              DL1A_SCL_LOW();                //SCL æ—¶é’Ÿçº¿æ‹‰ä½
  126   2          }
  127   1        dl1a_sccb_waitack();
  128   1      }
  129          
  130          
  131          //å­—èŠ‚æ¥æ”¶ç¨‹åº
  132          //æ¥æ”¶å™¨ä»¶ä¼ æ¥çš„æ•°æ®ï¼Œæ­¤ç¨‹åºåº”é…åˆ|ä¸»åº”ç­”å‡½æ•°|ä½¿ç”¨
  133          //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
  134          static uint8 dl1a_read_ch(uint8 ack_x)
  135          {
  136   1          uint8 i;
  137   1          uint8 c;
  138   1          c=0;
  139   1          DL1A_SCL_LOW();
  140   1          dl1a_simiic_delay();
  141   1          DL1A_SDA_HIGH();             
  142   1      
  143   1          for(i=0;i<8;i++)
  144   1          {
  145   2              dl1a_simiic_delay();
  146   2              DL1A_SCL_LOW();         //ç½®æ—¶é’Ÿçº¿ä¸ºä½ï¼Œå‡†å¤‡æ¥æ”¶æ•°æ®ä½
  147   2              dl1a_simiic_delay();
  148   2              DL1A_SCL_HIGH();         //ç½®æ—¶é’Ÿçº¿ä¸ºé«˜ï¼Œä½¿æ•°æ®çº¿ä¸Šæ•°æ®æœ‰æ•ˆ
  149   2              dl1a_simiic_delay();
  150   2              c<<=1;
  151   2              if(GET_DL1A_SDA) 
  152   2              {
  153   3                  c+=1;   //è¯»æ•°æ®ä½ï¼Œå°†æ¥æ”¶çš„æ•°æ®å­˜c
  154   3              }
  155   2          }
  156   1      
  157   1        DL1A_SCL_LOW();
  158   1        dl1a_simiic_delay();
  159   1        dl1a_simiic_sendack(ack_x);
  160   1        
  161   1          return c;
  162   1      }
  163          
  164          
  165          //-------------------------------------------------------------------------------------------------------
             -------------
  166          //  @brief      æ¨¡æ‹ŸIICå†™æ•°æ®åˆ°è®¾å¤‡å¯„å­˜å™¨å‡½æ•°
  167          //  @param      dev_add     è®¾å¤‡åœ°å€(ä½ä¸ƒä½åœ°å€)
  168          //  @param      reg       å¯„å­˜å™¨åœ°å€
  169          //  @param      dat       å†™å…¥çš„æ•°æ®
  170          //  @return     void            
  171          //  Sample usage:       
  172          //-------------------------------------------------------------------------------------------------------
             -------------
  173          static void dl1a_simiic_write_dats(uint8 dev_add, uint8 *dat, uint32 len)
  174          {
  175   1        dl1a_simiic_start();
  176   1          dl1a_send_ch( (dev_add<<1) | 0x00);   //å‘é€å™¨ä»¶åœ°å€åŠ å†™ä½
  177   1        while(len--)
  178   1        {
  179   2          dl1a_send_ch( *dat++ );            //å‘é€éœ€è¦å†™å…¥çš„æ•°æ®
  180   2        }
  181   1      
  182   1        
  183   1        dl1a_simiic_stop();
  184   1      }
C251 COMPILER V5.60.0,  DL1A                                                               25/04/24  13:33:30  PAGE 4   

  185          
  186          
  187          //-------------------------------------------------------------------------------------------------------
             -------------
  188          //  @brief      æ¨¡æ‹ŸIICå†™æ•°æ®åˆ°è®¾å¤‡å¯„å­˜å™¨å‡½æ•°
  189          //  @param      dev_add     è®¾å¤‡åœ°å€(ä½ä¸ƒä½åœ°å€)
  190          //  @param      reg       å¯„å­˜å™¨åœ°å€
  191          //  @param      dat       å†™å…¥çš„æ•°æ®
  192          //  @return     void            
  193          //  Sample usage:       
  194          //-------------------------------------------------------------------------------------------------------
             -------------
  195          static void dl1a_simiic_write_reg(uint8 dev_add, uint8 reg, uint8 dat)
  196          {
  197   1        dl1a_simiic_start();
  198   1          dl1a_send_ch( (dev_add<<1) | 0x00);   //å‘é€å™¨ä»¶åœ°å€åŠ å†™ä½
  199   1        dl1a_send_ch( reg );           //å‘é€ä»æœºå¯„å­˜å™¨åœ°å€
  200   1        dl1a_send_ch( dat );           //å‘é€éœ€è¦å†™å…¥çš„æ•°æ®
  201   1        dl1a_simiic_stop();
  202   1      }
  203          
  204          //-------------------------------------------------------------------------------------------------------
             -------------
  205          //  @brief      æ¨¡æ‹ŸIICä»è®¾å¤‡å¯„å­˜å™¨è¯»å–æ•°æ®
  206          //  @param      dev_add     è®¾å¤‡åœ°å€(ä½ä¸ƒä½åœ°å€)
  207          //  @param      reg       å¯„å­˜å™¨åœ°å€
  208          //  @param      type      é€‰æ‹©é€šä¿¡æ–¹å¼æ˜¯IIC  è¿˜æ˜¯ SCCB
  209          //  @return     uint8     è¿”å›å¯„å­˜å™¨çš„æ•°æ®      
  210          //  Sample usage:       
  211          //-------------------------------------------------------------------------------------------------------
             -------------
  212          static uint8 dl1a_simiic_read_reg(uint8 dev_add, uint8 reg)
  213          {
  214   1        uint8 dat;
  215   1        dl1a_simiic_start();
  216   1          dl1a_send_ch( (dev_add<<1) | 0x00);  //å‘é€å™¨ä»¶åœ°å€åŠ å†™ä½
  217   1        dl1a_send_ch( reg );          //å‘é€ä»æœºå¯„å­˜å™¨åœ°å€
  218   1      
  219   1        
  220   1        dl1a_simiic_start();
  221   1        dl1a_send_ch( (dev_add<<1) | 0x01);  //å‘é€å™¨ä»¶åœ°å€åŠ è¯»ä½
  222   1        dat = dl1a_read_ch(no_ack);           //è¯»å–æ•°æ®
  223   1        dl1a_simiic_stop();
  224   1        
  225   1        return dat;
  226   1      }
  227          
  228          //-------------------------------------------------------------------------------------------------------
             -------------
  229          //  @brief      æ¨¡æ‹ŸIICè¯»å–å¤šå­—èŠ‚æ•°æ®
  230          //  @param      dev_add     è®¾å¤‡åœ°å€(ä½ä¸ƒä½åœ°å€)
  231          //  @param      reg       å¯„å­˜å™¨åœ°å€
  232          //  @param      dat_add     æ•°æ®ä¿å­˜çš„åœ°å€æŒ‡é’ˆ
  233          //  @param      num       è¯»å–å­—èŠ‚æ•°é‡
  234          //  @param      type      é€‰æ‹©é€šä¿¡æ–¹å¼æ˜¯IIC  è¿˜æ˜¯ SCCB
  235          //  @return     uint8     è¿”å›å¯„å­˜å™¨çš„æ•°æ®      
  236          //  Sample usage:       
  237          //-------------------------------------------------------------------------------------------------------
             -------------
  238          static void dl1a_simiic_read_regs(uint8 dev_add, uint8 reg, uint8 *dat_add, uint32 num)
  239          {
  240   1        dl1a_simiic_start();
  241   1          dl1a_send_ch( (dev_add<<1) | 0x00);  //å‘é€å™¨ä»¶åœ°å€åŠ å†™ä½
  242   1        dl1a_send_ch( reg );          //å‘é€ä»æœºå¯„å­˜å™¨åœ°å€
  243   1      
  244   1        
C251 COMPILER V5.60.0,  DL1A                                                               25/04/24  13:33:30  PAGE 5   

  245   1        dl1a_simiic_start();
  246   1        dl1a_send_ch( (dev_add<<1) | 0x01);  //å‘é€å™¨ä»¶åœ°å€åŠ è¯»ä½
  247   1          while(--num)
  248   1          {
  249   2              *dat_add = dl1a_read_ch(ack); //è¯»å–æ•°æ®
  250   2              dat_add++;
  251   2          }
  252   1          *dat_add = dl1a_read_ch(no_ack); //è¯»å–æ•°æ®
  253   1        dl1a_simiic_stop();
  254   1      }
  255          
  256          //-------------------------------------------------------------------------------------------------------
             -------------
  257          //  @brief      æ¨¡æ‹ŸIICè¯»å–å¤šå­—èŠ‚æ•°æ®
  258          //  @param      dev_add     è®¾å¤‡åœ°å€(ä½ä¸ƒä½åœ°å€)
  259          //  @param      reg       å¯„å­˜å™¨åœ°å€
  260          //  @param      dat_add     æ•°æ®ä¿å­˜çš„åœ°å€æŒ‡é’ˆ
  261          //  @param      num       è¯»å–å­—èŠ‚æ•°é‡
  262          //  @param      type      é€‰æ‹©é€šä¿¡æ–¹å¼æ˜¯IIC  è¿˜æ˜¯ SCCB
  263          //  @return     uint8     è¿”å›å¯„å­˜å™¨çš„æ•°æ®      
  264          //  Sample usage:       
  265          //-------------------------------------------------------------------------------------------------------
             -------------
  266          static void dl1a_simiic_read_regs_1(uint8 dev_add, uint8 reg, uint8 *dat_add, uint32 num)
  267          {
  268   1        dl1a_simiic_start();
  269   1          dl1a_send_ch( (dev_add<<1) | 0x00);  //å‘é€å™¨ä»¶åœ°å€åŠ å†™ä½
  270   1        dl1a_send_ch( reg );          //å‘é€ä»æœºå¯„å­˜å™¨åœ°å€
  271   1      
  272   1        
  273   1        dl1a_simiic_start();
  274   1        dl1a_send_ch( (dev_add<<1) | 0x01);  //å‘é€å™¨ä»¶åœ°å€åŠ è¯»ä½
  275   1          while(--num)
  276   1          {
  277   2              *dat_add = dl1a_read_ch(ack); //è¯»å–æ•°æ®
  278   2              dat_add++;
  279   2          }
  280   1          *dat_add = dl1a_read_ch(no_ack); //è¯»å–æ•°æ®
  281   1        dl1a_simiic_stop();
  282   1      }
  283          
  284          
  285          #define dl1a_write_array(dat, len)          (dl1a_simiic_write_dats(DL1A_DEV_ADDR, (dat), (len)))
  286          #define dl1a_write_register(reg, dat)       (dl1a_simiic_write_reg(DL1A_DEV_ADDR, (reg), (dat)))
  287          #define dl1a_read_register(reg)             (dl1a_simiic_read_reg (DL1A_DEV_ADDR, (reg)))
  288          #define dl1a_read_registers(reg, dat, len)  (dl1a_simiic_read_regs(DL1A_DEV_ADDR, (reg), (dat), (len)))
  289          #define dl1a_read_registers_1(reg, dat, len)  (dl1a_simiic_read_regs_1(DL1A_DEV_ADDR, (reg), (dat), (len)
             -))
  290          
  291          // è¿™ä¸ªé€Ÿç‡è¡¨ç¤ºä»ç›®æ ‡åå°„å¹¶è¢«è®¾å¤‡æ£€æµ‹åˆ°çš„ä¿¡å·çš„æŒ¯å¹…
  292          // è®¾ç½®æ­¤é™åˆ¶å¯ä»¥ç¡®å®šä¼ æ„Ÿå™¨æŠ¥å‘Šæœ‰æ•ˆè¯»æ•°æ‰€éœ€çš„æœ€å°æµ‹é‡å€¼
  293          // è®¾ç½®ä¸€ä¸ªè¾ƒä½çš„é™åˆ¶å¯ä»¥å¢åŠ ä¼ æ„Ÿå™¨çš„æµ‹é‡èŒƒå›´
  294          // ä½†ä¼¼ä¹ä¹Ÿå¢åŠ äº† <ç”±äºæ¥è‡ªç›®æ ‡ä»¥å¤–çš„ç‰©ä½“çš„ä¸éœ€è¦çš„åå°„å¯¼è‡´> å¾—åˆ°ä¸å‡†ç¡®è¯
             -»æ•°çš„å¯èƒ½æ€§
  295          // é»˜è®¤ä¸º 0.25 MCPS å¯é¢„è®¾èŒƒå›´ä¸º 0 - 511.99
  296          #define DL1A_DEFAULT_RATE_LIMIT  (0.25)
  297          
  298          // ä»å¯„å­˜å™¨æ•°æ®è§£ç  PCLKs ä¸­ VCSEL (vertical cavity surface emitting laser) çš„è„‰å®½å‘¨æœŸ
  299          #define decode_vcsel_period(reg_val)            (((reg_val) + 1) << 1)
  300          
  301          // ä» PCLK ä¸­çš„ VCSEL å‘¨æœŸè®¡ç®—å®å‘¨æœŸ (ä»¥ *çº³ç§’ä¸ºå•ä½)
  302          // PLL_period_ps = 1655
  303          // macro_period_vclks = 2304
  304          #define calc_macro_period(vcsel_period_pclks)   ((((uint32)2304 * (vcsel_period_pclks) * 1655) + 500) / 1
             -000)
  305          
C251 COMPILER V5.60.0,  DL1A                                                               25/04/24  13:33:30  PAGE 6   

  306          //-------------------------------------------------------------------------------------------------------
             -------------
  307          // å‡½æ•°ç®€ä»‹     è·å–è®¾å¤‡ SPAD ä¿¡æ¯
  308          // å‚æ•°è¯´æ˜     index           ç´¢å¼•
  309          // å‚æ•°è¯´æ˜     type            ç±»å‹å€¼
  310          // è¿”å›å‚æ•°     uint8           æ˜¯å¦æˆåŠŸ 0-æˆåŠŸ 1-å¤±è´¥
  311          // ä½¿ç”¨ç¤ºä¾‹     dl1a_get_spad_info(index, type_is_aperture);
  312          // å¤‡æ³¨ä¿¡æ¯     
  313          //-------------------------------------------------------------------------------------------------------
             -------------
  314          static uint8 dl1a_get_spad_info (uint8 *index, uint8 *type_is_aperture)
  315          {
  316   1          uint8 tmp = 0;
  317   1          uint8 return_state = 0;
  318   1          volatile uint16 loop_count = 0;
  319   1      
  320   1          do
  321   1          {
  322   2              dl1a_write_register(0x80, 0x01);
  323   2              dl1a_write_register(0xFF, 0x01);
  324   2              dl1a_write_register(0x00, 0x00);
  325   2      
  326   2              dl1a_write_register(0xFF, 0x06);
  327   2              dl1a_read_registers(0x83, &tmp, 1);
  328   2              dl1a_write_register(0x83, tmp | 0x04);
  329   2              dl1a_write_register(0xFF, 0x07);
  330   2              dl1a_write_register(0x81, 0x01);
  331   2      
  332   2              dl1a_write_register(0x80, 0x01);
  333   2      
  334   2              dl1a_write_register(0x94, 0x6b);
  335   2              dl1a_write_register(0x83, 0x00);
  336   2      
  337   2              tmp = 0x00;
  338   2              while(tmp != 0x10)
  339   2              {
  340   3                  dl1a_read_registers(0x83, &tmp, 1);
  341   3                  loop_count++;
  342   3                  if(loop_count == DL1A_TIMEOUT_COUNT)
  343   3                  {
  344   4                      return_state = 1;
  345   4                      break;
  346   4                  }
  347   3              }
  348   2          
  349   2              if(return_state)
  350   2              {
  351   3                  break;
  352   3              }
  353   2              dl1a_write_register(0x83, 0x01);
  354   2              dl1a_read_registers(0x92, &tmp, 1);
  355   2      
  356   2              *index = tmp & 0x7f;
  357   2              *type_is_aperture = (tmp >> 7) & 0x01;
  358   2      
  359   2              dl1a_write_register(0x81, 0x00);
  360   2              dl1a_write_register(0xFF, 0x06);
  361   2              dl1a_read_registers(0x83, &tmp, 1);
  362   2              dl1a_write_register(0x83, tmp);
  363   2              dl1a_write_register(0xFF, 0x01);
  364   2              dl1a_write_register(0x00, 0x01);
  365   2      
  366   2              dl1a_write_register(0xFF, 0x00);
  367   2              dl1a_write_register(0x80, 0x00);
  368   2          }while(0);
  369   1      
C251 COMPILER V5.60.0,  DL1A                                                               25/04/24  13:33:30  PAGE 7   

  370   1          return return_state;
  371   1      }
  372          
  373          //-------------------------------------------------------------------------------------------------------
             -------------
  374          // å‡½æ•°ç®€ä»‹     å°†è¶…æ—¶æ•°å€¼ä» MCLKs è½¬æ¢åˆ°å¯¹åº”çš„ ms
  375          // å‚æ•°è¯´æ˜     timeout_period_mclks    è¶…æ—¶å‘¨æœŸ MCLKs
  376          // å‚æ•°è¯´æ˜     vcsel_period_pclks      PCLK å€¼
  377          // è¿”å›å‚æ•°     uint32                  è¿”å›è¶…æ—¶æ•°å€¼
  378          // ä½¿ç”¨ç¤ºä¾‹     dl1a_timeout_mclks_to_microseconds(timeout_period_mclks, vcsel_period_pclks);
  379          // å¤‡æ³¨ä¿¡æ¯     å°†åºåˆ—æ­¥éª¤è¶…æ—¶ä»å…·æœ‰ç»™å®š VCSEL å‘¨æœŸçš„ MCLK (ä»¥ PCLK ä¸ºå•ä½)è½¬æ¢ä
             -¸ºå¾®ç§’
  380          //-------------------------------------------------------------------------------------------------------
             -------------
  381          static uint32 dl1a_timeout_mclks_to_microseconds (uint16 timeout_period_mclks, uint8 vcsel_period_pclks)
  382          {
  383   1          uint32 macro_period_ns = calc_macro_period(vcsel_period_pclks);
  384   1      
  385   1          return ((timeout_period_mclks * macro_period_ns) + (macro_period_ns / 2)) / 1000;
  386   1      }
  387          
  388          //-------------------------------------------------------------------------------------------------------
             -------------
  389          // å‡½æ•°ç®€ä»‹     å°†è¶…æ—¶æ•°å€¼ä» ms è½¬æ¢åˆ°å¯¹åº”çš„ MCLKs
  390          // å‚æ•°è¯´æ˜     timeout_period_us   è¶…æ—¶å‘¨æœŸ å¾®ç§’å•ä½
  391          // å‚æ•°è¯´æ˜     vcsel_period_pclks  PCLK å€¼
  392          // è¿”å›å‚æ•°     uint32              è¿”å›è¶…æ—¶æ•°å€¼
  393          // ä½¿ç”¨ç¤ºä¾‹     dl1a_timeout_microseconds_to_mclks(timeout_period_us, vcsel_period_pclks);
  394          // å¤‡æ³¨ä¿¡æ¯     å°†åºåˆ—æ­¥éª¤è¶…æ—¶ä»å¾®ç§’è½¬æ¢ä¸ºå…·æœ‰ç»™å®š VCSEL å‘¨æœŸçš„ MCLK (ä»¥ PCLK ä¸
             -ºå•ä½)
  395          //-------------------------------------------------------------------------------------------------------
             -------------
  396          static uint32 dl1a_timeout_microseconds_to_mclks (uint32 timeout_period_us, uint8 vcsel_period_pclks)
  397          {
  398   1          uint32 macro_period_ns = calc_macro_period(vcsel_period_pclks);
  399   1      
  400   1          return (((timeout_period_us * 1000) + (macro_period_ns / 2)) / macro_period_ns);
  401   1      }
  402          
  403          //-------------------------------------------------------------------------------------------------------
             -------------
  404          // å‡½æ•°ç®€ä»‹     å¯¹è¶…æ—¶æ•°å€¼è¿›è¡Œè§£ç 
  405          // å‚æ•°è¯´æ˜     reg_val         è¶…æ—¶æ—¶é•¿ å¯„å­˜å™¨å€¼
  406          // è¿”å›å‚æ•°     uint16          è¿”å›è¶…æ—¶æ•°å€¼
  407          // ä½¿ç”¨ç¤ºä¾‹     dl1a_decode_timeout(reg_val);
  408          // å¤‡æ³¨ä¿¡æ¯     ä»å¯„å­˜å™¨å€¼è§£ç  MCLK ä¸­çš„åºåˆ—æ­¥éª¤è¶…æ—¶   
  409          //-------------------------------------------------------------------------------------------------------
             -------------
  410          static uint16 dl1a_decode_timeout (uint16 reg_val)
  411          {
  412   1        // æ ¼å¼: (LSByte * 2 ^ MSByte) + 1
  413   1          return  (uint16)((reg_val & 0x00FF) <<
  414   1                  (uint16)((reg_val & 0xFF00) >> 8)) + 1;
  415   1      }
  416          
  417          //-------------------------------------------------------------------------------------------------------
             -------------
  418          // å‡½æ•°ç®€ä»‹     å¯¹è¶…æ—¶æ•°å€¼è¿›è¡Œç¼–ç 
  419          // å‚æ•°è¯´æ˜     timeout_mclks   è¶…æ—¶æ—¶é•¿ -MCLKs å€¼
  420          // è¿”å›å‚æ•°     uint16          è¿”å›ç¼–ç å€¼
  421          // ä½¿ç”¨ç¤ºä¾‹     dl1a_encode_timeout(timeout_mclks);
  422          // å¤‡æ³¨ä¿¡æ¯     åœ¨ MCLK ä¸­å¯¹è¶…æ—¶çš„åºåˆ—æ­¥éª¤è¶…æ—¶å¯„å­˜å™¨å€¼è¿›è¡Œç¼–ç 
  423          //-------------------------------------------------------------------------------------------------------
             -------------
  424          static uint16 dl1a_encode_timeout (uint16 timeout_mclks)
  425          {
C251 COMPILER V5.60.0,  DL1A                                                               25/04/24  13:33:30  PAGE 8   

  426   1          uint32 ls_byte = 0;
  427   1          uint16 ms_byte = 0;
  428   1          uint16 return_data = 0;
  429   1      
  430   1          if (timeout_mclks > 0)
  431   1          {
  432   2              // æ ¼å¼: (LSByte * 2 ^ MSByte) + 1
  433   2              ls_byte = timeout_mclks - 1;
  434   2              while ((ls_byte & 0xFFFFFF00) > 0)
  435   2              {
  436   3                  ls_byte >>= 1;
  437   3                  ms_byte++;
  438   3              }
  439   2              return_data = (ms_byte << 8) | (ls_byte & 0xFF);
  440   2          }
  441   1          return return_data;
  442   1      }
  443          
  444          //-------------------------------------------------------------------------------------------------------
             -------------
  445          // å‡½æ•°ç®€ä»‹     è·å–åºåˆ—æ­¥éª¤ä½¿èƒ½è®¾ç½®
  446          // å‚æ•°è¯´æ˜     enables         åºåˆ—ä½¿èƒ½æ­¥éª¤ç»“æ„ä½“
  447          // è¿”å›å‚æ•°     void
  448          // ä½¿ç”¨ç¤ºä¾‹     dl1a_get_sequence_step_enables(enables);
  449          // å¤‡æ³¨ä¿¡æ¯     
  450          //-------------------------------------------------------------------------------------------------------
             -------------
  451          static void dl1a_get_sequence_step_enables(dl1a_sequence_enables_step_struct *enables)
  452          {
  453   1          uint8 sequence_config = 0;
  454   1          dl1a_read_registers(DL1A_SYSTEM_SEQUENCE_CONFIG, &sequence_config, 1);
  455   1      
  456   1          enables->tcc          = (sequence_config >> 4) & 0x1;
  457   1          enables->dss          = (sequence_config >> 3) & 0x1;
  458   1          enables->msrc         = (sequence_config >> 2) & 0x1;
  459   1          enables->pre_range    = (sequence_config >> 6) & 0x1;
  460   1          enables->final_range  = (sequence_config >> 7) & 0x1;
  461   1      }
  462          
  463          //-------------------------------------------------------------------------------------------------------
             -------------
  464          // å‡½æ•°ç®€ä»‹     è·å–è„‰å†²å‘¨æœŸ
  465          // å‚æ•°è¯´æ˜     type            é¢„é‡ç¨‹ç±»å‹
  466          // è¿”å›å‚æ•°     uint8           è¿”å›çš„å‘¨æœŸå€¼
  467          // ä½¿ç”¨ç¤ºä¾‹     dl1a_get_vcsel_pulse_period(DL1A_VCSEL_PERIOD_PER_RANGE);
  468          // å¤‡æ³¨ä¿¡æ¯     åœ¨ PCLKs ä¸­è·å–ç»™å®šå‘¨æœŸç±»å‹çš„ VCSEL è„‰å†²å‘¨æœŸ
  469          //-------------------------------------------------------------------------------------------------------
             -------------
  470          static uint8 dl1a_get_vcsel_pulse_period (dl1a_vcsel_period_type_enum type)
  471          {
  472   1          uint8 data_buffer = 0;
  473   1          if (type == DL1A_VCSEL_PERIOD_PER_RANGE)
  474   1          {
  475   2              dl1a_read_registers(DL1A_PRE_RANGE_CONFIG_VCSEL_PERIOD, &data_buffer, 1);
  476   2              data_buffer = decode_vcsel_period(data_buffer);
  477   2          }
  478   1          else if (type == DL1A_VCSEL_PERIOD_FINAL_RANGE)
  479   1          {
  480   2              dl1a_read_registers(DL1A_FINAL_RANGE_CONFIG_VCSEL_PERIOD, &data_buffer, 1);
  481   2              data_buffer = decode_vcsel_period(data_buffer);
  482   2          }
  483   1          else
  484   1          {
  485   2              data_buffer = 255;
  486   2          }
  487   1          return data_buffer;
C251 COMPILER V5.60.0,  DL1A                                                               25/04/24  13:33:30  PAGE 9   

  488   1      }
  489          
  490          //-------------------------------------------------------------------------------------------------------
             -------------
  491          // å‡½æ•°ç®€ä»‹     è·å–åºåˆ—æ­¥éª¤è¶…æ—¶è®¾ç½®
  492          // å‚æ•°è¯´æ˜     enables         åºåˆ—ä½¿èƒ½æ­¥éª¤ç»“æ„ä½“
  493          // å‚æ•°è¯´æ˜     timeouts        åºåˆ—è¶…æ—¶æ­¥éª¤ç»“æ„ä½“
  494          // è¿”å›å‚æ•°     void
  495          // ä½¿ç”¨ç¤ºä¾‹     dl1a_get_sequence_step_timeouts(enables, timeouts);
  496          // å¤‡æ³¨ä¿¡æ¯     è·å–æ‰€æœ‰è¶…æ—¶è€Œä¸ä»…ä»…æ˜¯è¯·æ±‚çš„è¶…æ—¶ å¹¶ä¸”è¿˜å­˜å‚¨ä¸­é—´å€¼
  497          //-------------------------------------------------------------------------------------------------------
             -------------
  498          static void dl1a_get_sequence_step_timeouts (dl1a_sequence_enables_step_struct const *enables, dl1a_seque
             -nce_timeout_step_struct *timeouts)
  499          {
  500   1          uint8 reg_buffer[2];
  501   1          uint16 reg16_buffer = 0;
  502   1      
  503   1          timeouts->pre_range_vcsel_period_pclks = dl1a_get_vcsel_pulse_period(DL1A_VCSEL_PERIOD_PER_RANGE);
  504   1      
  505   1          dl1a_read_registers(DL1A_MSRC_CONFIG_TIMEOUT_MACROP, reg_buffer, 1);
  506   1          timeouts->msrc_dss_tcc_mclks = reg_buffer[0] + 1;
  507   1          timeouts->msrc_dss_tcc_us = dl1a_timeout_mclks_to_microseconds(timeouts->msrc_dss_tcc_mclks, (uint8)t
             -imeouts->pre_range_vcsel_period_pclks);
  508   1      
  509   1          dl1a_read_registers(DL1A_PRE_RANGE_CONFIG_TIMEOUT_MACROP_HI, reg_buffer, 2);
  510   1          reg16_buffer = ((uint16) reg_buffer[0] << 8) | reg_buffer[1];
  511   1          timeouts->pre_range_mclks = dl1a_decode_timeout(reg16_buffer);
  512   1          timeouts->pre_range_us = dl1a_timeout_mclks_to_microseconds(timeouts->pre_range_mclks, (uint8)timeout
             -s->pre_range_vcsel_period_pclks);
  513   1      
  514   1          timeouts->final_range_vcsel_period_pclks = dl1a_get_vcsel_pulse_period(DL1A_VCSEL_PERIOD_FINAL_RANGE)
             -;
  515   1      
  516   1          dl1a_read_registers(DL1A_FINAL_RANGE_CONFIG_TIMEOUT_MACROP_HI, reg_buffer, 2);
  517   1          reg16_buffer = ((uint16) reg_buffer[0] << 8) | reg_buffer[1];
  518   1          timeouts->final_range_mclks = dl1a_decode_timeout(reg16_buffer);
  519   1      
  520   1          if (enables->pre_range)
  521   1          {
  522   2              timeouts->final_range_mclks -= timeouts->pre_range_mclks;
  523   2          }
  524   1      
  525   1          timeouts->final_range_us = dl1a_timeout_mclks_to_microseconds(timeouts->final_range_mclks, (uint8)tim
             -eouts->final_range_vcsel_period_pclks);
  526   1      }
  527          
  528          //-------------------------------------------------------------------------------------------------------
             -------------
  529          // å‡½æ•°ç®€ä»‹     æ‰§è¡Œå•æ¬¡å‚è€ƒæ ¡å‡†
  530          // å‚æ•°è¯´æ˜     vhv_init_byte   é¢„è®¾æ ¡å‡†å€¼
  531          // è¿”å›å‚æ•°     uint8           æ“ä½œæ˜¯å¦æˆåŠŸ 0-æˆåŠŸ 1-å¤±è´¥
  532          // ä½¿ç”¨ç¤ºä¾‹     dl1a_get_vcsel_pulse_period(DL1A_VCSEL_PERIOD_PER_RANGE);
  533          // å¤‡æ³¨ä¿¡æ¯     åœ¨ PCLKs ä¸­è·å–ç»™å®šå‘¨æœŸç±»å‹çš„ VCSEL è„‰å†²å‘¨æœŸ
  534          //-------------------------------------------------------------------------------------------------------
             -------------
  535          static uint8 dl1a_perform_single_ref_calibration (uint8 vhv_init_byte)
  536          {
  537   1          uint8 return_state = 0;
  538   1          uint8 data_buffer = 0;
  539   1          volatile uint16 loop_count = 0;
  540   1          do
  541   1          {
  542   2              dl1a_write_register(DL1A_SYSRANGE_START, 0x01 | vhv_init_byte);
  543   2              dl1a_read_registers(DL1A_MSRC_CONFIG_TIMEOUT_MACROP, &data_buffer, 1);
  544   2              while ((data_buffer & 0x07) == 0)
C251 COMPILER V5.60.0,  DL1A                                                               25/04/24  13:33:30  PAGE 10  

  545   2              {
  546   3                  if (loop_count > 0x8fe0)
  547   3                  {
  548   4                      return_state = 1;
  549   4                      break;
  550   4                  }
  551   3                  if (loop_count++ % 0x10 == 0)
  552   3                  {
  553   4                      dl1a_read_registers(DL1A_MSRC_CONFIG_TIMEOUT_MACROP, &data_buffer, 1);
  554   4                  }
  555   3              }
  556   2              if(return_state)
  557   2              {
  558   3                  break;
  559   3              }
  560   2              dl1a_write_register(DL1A_SYSTEM_INTERRUPT_CLEAR, 0x01);
  561   2              dl1a_write_register(DL1A_SYSRANGE_START, 0x00);
  562   2          }while(0);
  563   1      
  564   1          return return_state;
  565   1      }
  566          
  567          //-------------------------------------------------------------------------------------------------------
             -------------
  568          // å‡½æ•°ç®€ä»‹     è®¾ç½®æµ‹é‡å®šæ—¶é¢„ç®— (ä»¥å¾®ç§’ä¸ºå•ä½)
  569          // å‚æ•°è¯´æ˜     budget_us       è®¾å®šçš„æµ‹é‡å…è®¸çš„æ—¶é—´
  570          // è¿”å›å‚æ•°     uint8           æ“ä½œç»“æœ 0-æˆåŠŸ 1-å¤±è´¥
  571          // ä½¿ç”¨ç¤ºä¾‹     dl1a_set_measurement_timing_budget(measurement_timing_budget_us);
  572          // å¤‡æ³¨ä¿¡æ¯     è¿™æ˜¯ä¸€æ¬¡æµ‹é‡å…è®¸çš„æ—¶é—´
  573          //              å³åœ¨æµ‹è·åºåˆ—çš„å­æ­¥éª¤ä¹‹é—´åˆ†é…æ—¶é—´é¢„ç®—
  574          //              æ›´é•¿çš„æ—¶é—´é¢„ç®—å…è®¸æ›´ç²¾ç¡®çš„æµ‹é‡
  575          //              å¢åŠ ä¸€ä¸ªNå€çš„é¢„ç®—å¯ä»¥å‡å°‘ä¸€ä¸ªsqrt(N)å€çš„èŒƒå›´æµ‹é‡æ ‡å‡†åå·®
  576          //              é»˜è®¤ä¸º33æ¯«ç§’ æœ€å°å€¼ä¸º20 ms
  577          //-------------------------------------------------------------------------------------------------------
             -------------
  578          static uint8 dl1a_set_measurement_timing_budget (uint32 budget_us)
  579          {
  580   1          uint8 return_state = 0;
  581   1          uint8 data_buffer[3];
  582   1          uint16 dat = 0;
  583   1        uint32 used_budget_us;
  584   1        uint32 final_range_timeout_us;
  585   1        uint16 final_range_timeout_mclks;
  586   1        
  587   1          dl1a_sequence_enables_step_struct enables;
  588   1          dl1a_sequence_timeout_step_struct timeouts;
  589   1      
  590   1          do
  591   1          {
  592   2              if (budget_us < DL1A_MIN_TIMING_BUDGET)
  593   2              {
  594   3                  return_state = 1;
  595   3                  break;
  596   3              }
  597   2      
  598   2              used_budget_us = DL1A_SET_START_OVERHEAD + DL1A_END_OVERHEAD;
  599   2              dl1a_get_sequence_step_enables(&enables);
  600   2              dl1a_get_sequence_step_timeouts(&enables, &timeouts);
  601   2      
  602   2              if (enables.tcc)
  603   2              {
  604   3                  used_budget_us += (timeouts.msrc_dss_tcc_us + DL1A_TCC_OVERHEAD);
  605   3              }
  606   2      
  607   2              if (enables.dss)
  608   2              {
C251 COMPILER V5.60.0,  DL1A                                                               25/04/24  13:33:30  PAGE 11  

  609   3                  used_budget_us += 2 * (timeouts.msrc_dss_tcc_us + DL1A_DSS_OVERHEAD);
  610   3              }
  611   2              else if (enables.msrc)
  612   2              {
  613   3                  used_budget_us += (timeouts.msrc_dss_tcc_us + DL1A_MSRC_OVERHEAD);
  614   3              }
  615   2      
  616   2              if (enables.pre_range)
  617   2              {
  618   3                  used_budget_us += (timeouts.pre_range_us + DL1A_PRERANGE_OVERHEAD);
  619   3              }
  620   2      
  621   2              if (enables.final_range)
  622   2              {
  623   3                  // è¯·æ³¨æ„ æœ€ç»ˆèŒƒå›´è¶…æ—¶ç”±è®¡æ—¶é¢„ç®—å’Œåºåˆ—ä¸­æ‰€æœ‰å…¶ä»–è¶…æ—¶çš„æ€»å’Œå†³å®š
  624   3                  // å¦‚æœæ²¡æœ‰ç©ºé—´ç”¨äºæœ€ç»ˆèŒƒå›´è¶…æ—¶ åˆ™å°†è®¾ç½®é”™è¯¯
  625   3                  // å¦åˆ™ å‰©ä½™æ—¶é—´å°†åº”ç”¨äºæœ€ç»ˆèŒƒå›´
  626   3                  used_budget_us += DL1A_FINALlRANGE_OVERHEAD;
  627   3                  if (used_budget_us > budget_us)
  628   3                  {
  629   4                      // è¯·æ±‚çš„è¶…æ—¶å¤ªå¤§
  630   4                      return_state = 1;
  631   4                      break;
  632   4                  }
  633   3      
  634   3                  // å¯¹äºæœ€ç»ˆè¶…æ—¶èŒƒå›´ å¿…é¡»æ·»åŠ é¢„é‡ç¨‹èŒƒå›´è¶…æ—¶
  635   3                  // ä¸ºæ­¤ æœ€ç»ˆè¶…æ—¶å’Œé¢„é‡ç¨‹è¶…æ—¶å¿…é¡»ä»¥å®å‘¨æœŸ MClks è¡¨ç¤º
  636   3                  // å› ä¸ºå®ƒä»¬å…·æœ‰ä¸åŒçš„ VCSEL å‘¨æœŸ
  637   3                  final_range_timeout_us = budget_us - used_budget_us;
  638   3                  final_range_timeout_mclks =
  639   3                  dl1a_timeout_microseconds_to_mclks(final_range_timeout_us,
  640   3                           (uint8)timeouts.final_range_vcsel_period_pclks);
  641   3      
  642   3                  if (enables.pre_range)
  643   3                  {
  644   4                      final_range_timeout_mclks += timeouts.pre_range_mclks;
  645   4                  }
  646   3      
  647   3                  dat = dl1a_encode_timeout(final_range_timeout_mclks);
  648   3                  data_buffer[0] = DL1A_FINAL_RANGE_CONFIG_TIMEOUT_MACROP_HI;
  649   3                  data_buffer[1] = ((dat >> 8) & 0xFF);
  650   3                  data_buffer[2] = (dat & 0xFF);
  651   3                  dl1a_write_array(data_buffer, 3);
  652   3              }
  653   2          }while(0);
  654   1          return return_state;
  655   1      }
  656          
  657          //-------------------------------------------------------------------------------------------------------
             -------------
  658          // å‡½æ•°ç®€ä»‹     è·å–æµ‹é‡å®šæ—¶é¢„ç®— (ä»¥å¾®ç§’ä¸ºå•ä½)
  659          // å‚æ•°è¯´æ˜     void
  660          // è¿”å›å‚æ•°     uint32          å·²è®¾å®šçš„æµ‹é‡å…è®¸çš„æ—¶é—´
  661          // ä½¿ç”¨ç¤ºä¾‹     dl1a_get_measurement_timing_budget();
  662          // å¤‡æ³¨ä¿¡æ¯     
  663          //-------------------------------------------------------------------------------------------------------
             -------------
  664          static uint32 dl1a_get_measurement_timing_budget (void)
  665          {
  666   1          dl1a_sequence_enables_step_struct enables;
  667   1          dl1a_sequence_timeout_step_struct timeouts;
  668   1      
  669   1          // å¼€å§‹å’Œç»“æŸå¼€é”€æ—¶é—´å§‹ç»ˆå­˜åœ¨
  670   1          uint32 budget_us = DL1A_GET_START_OVERHEAD + DL1A_END_OVERHEAD;
  671   1      
  672   1          dl1a_get_sequence_step_enables(&enables);
C251 COMPILER V5.60.0,  DL1A                                                               25/04/24  13:33:30  PAGE 12  

  673   1          dl1a_get_sequence_step_timeouts(&enables, &timeouts);
  674   1      
  675   1          if (enables.tcc)
  676   1          {
  677   2              budget_us += (timeouts.msrc_dss_tcc_us + DL1A_TCC_OVERHEAD);
  678   2          }
  679   1      
  680   1          if (enables.dss)
  681   1          {
  682   2              budget_us += 2 * (timeouts.msrc_dss_tcc_us + DL1A_DSS_OVERHEAD);
  683   2          }
  684   1          else if (enables.msrc)
  685   1          {
  686   2              budget_us += (timeouts.msrc_dss_tcc_us + DL1A_MSRC_OVERHEAD);
  687   2          }
  688   1      
  689   1          if (enables.pre_range)
  690   1          {
  691   2              budget_us += (timeouts.pre_range_us + DL1A_PRERANGE_OVERHEAD);
  692   2          }
  693   1      
  694   1          if (enables.final_range)
  695   1          {
  696   2              budget_us += (timeouts.final_range_us + DL1A_FINALlRANGE_OVERHEAD);
  697   2          }
  698   1      
  699   1          return budget_us;
  700   1      }
  701          
  702          //-------------------------------------------------------------------------------------------------------
             -------------
  703          // å‡½æ•°ç®€ä»‹     è®¾ç½®è¿”å›ä¿¡å·é€Ÿç‡é™åˆ¶ è¯¥å€¼å•ä½ä¸º MCPS (ç™¾ä¸‡æ¬¡æ¯ç§’)
  704          // å‚æ•°è¯´æ˜     limit_mcps      è®¾ç½®çš„æœ€å°é€Ÿç‡
  705          // è¿”å›å‚æ•°     void
  706          // ä½¿ç”¨ç¤ºä¾‹     dl1a_set_signal_rate_limit(0.25);
  707          // å¤‡æ³¨ä¿¡æ¯     è¿™ä¸ªé€Ÿç‡è¡¨ç¤ºä»ç›®æ ‡åå°„å¹¶è¢«è®¾å¤‡æ£€æµ‹åˆ°çš„ä¿¡å·çš„æŒ¯å¹…
  708          //              è®¾ç½®æ­¤é™åˆ¶å¯ä»¥ç¡®å®šä¼ æ„Ÿå™¨æŠ¥å‘Šæœ‰æ•ˆè¯»æ•°æ‰€éœ€çš„æœ€å°æµ‹é‡å€¼
  709          //              è®¾ç½®ä¸€ä¸ªè¾ƒä½çš„é™åˆ¶å¯ä»¥å¢åŠ ä¼ æ„Ÿå™¨çš„æµ‹é‡èŒƒå›´
  710          //              ä½†ä¼¼ä¹ä¹Ÿå¢åŠ äº† <ç”±äºæ¥è‡ªç›®æ ‡ä»¥å¤–çš„ç‰©ä½“çš„ä¸éœ€è¦çš„åå°„å¯¼è‡´> å¾—å
             -ˆ°ä¸å‡†ç¡®è¯»æ•°çš„å¯èƒ½æ€§
  711          //              é»˜è®¤ä¸º 0.25 MCPS å¯é¢„è®¾èŒƒå›´ä¸º 0 - 511.99
  712          //-------------------------------------------------------------------------------------------------------
             -------------
  713          static void dl1a_set_signal_rate_limit (float limit_mcps)
  714          {
  715   1        uint8 data_buffer[3];
  716   1          uint16 limit_mcps_16bit = (limit_mcps * (1 << 7));
  717   1          //assert(limit_mcps >= 0 || limit_mcps <= 511.99);
  718   1      
  719   1      
  720   1          data_buffer[0] = DL1A_FINAL_RANGE_CONFIG_MIN_COUNT_RATE_RTN_LIMIT;
  721   1          data_buffer[1] = ((limit_mcps_16bit >> 8) & 0xFF);
  722   1          data_buffer[2] = (limit_mcps_16bit & 0xFF);
  723   1      
  724   1          dl1a_write_array(data_buffer, 3);
  725   1      }
  726          
  727          //-------------------------------------------------------------------------------------------------------
             -------------
  728          // å‡½æ•°ç®€ä»‹     è¿”å›ä»¥æ¯«ç±³ä¸ºå•ä½çš„èŒƒå›´è¯»æ•°
  729          // å‚æ•°è¯´æ˜     void
  730          // è¿”å›å‚æ•°     uint8           0-æ•°æ®æ— æ•ˆ 1-æ•°æ®æœ‰æ•ˆ
  731          // ä½¿ç”¨ç¤ºä¾‹     dl1a_get_distance();
  732          // å¤‡æ³¨ä¿¡æ¯     åœ¨å¼€å§‹å•æ¬¡å°„ç¨‹æµ‹é‡åä¹Ÿè°ƒç”¨æ­¤å‡½æ•°
  733          //-------------------------------------------------------------------------------------------------------
             -------------
C251 COMPILER V5.60.0,  DL1A                                                               25/04/24  13:33:30  PAGE 13  

  734          void dl1a_get_distance (void)
  735          {
  736   1          uint8 reg_databuffer[3];
  737   1      
  738   1          dl1a_read_registers_1(DL1A_RESULT_INTERRUPT_STATUS, reg_databuffer, 1);
  739   1          if((reg_databuffer[0] & 0x07) == 0)
  740   1          {
  741   2              dl1a_finsh_flag = 0;
  742   2          }
  743   1          else
  744   1          {
  745   2              // å‡è®¾çº¿æ€§åº¦æ ¡æ­£å¢ç›Šä¸ºé»˜è®¤å€¼ 1000 ä¸”æœªå¯ç”¨åˆ†æ•°èŒƒå›´
  746   2              dl1a_read_registers_1(DL1A_RESULT_RANGE_STATUS + 10, reg_databuffer, 2);
  747   2              dl1a_distance_mm = ((uint16)reg_databuffer[0] << 8);
  748   2              dl1a_distance_mm |= reg_databuffer[1];
  749   2      
  750   2              dl1a_write_register(DL1A_SYSTEM_INTERRUPT_CLEAR, 0x01);
  751   2              dl1a_finsh_flag = 1;
  752   2          }
  753   1      }
  754          
  755          //-------------------------------------------------------------------------------------------------------
             -------------
  756          // å‡½æ•°ç®€ä»‹     åˆå§‹åŒ– DL1A
  757          // å‚æ•°è¯´æ˜     void
  758          // è¿”å›å‚æ•°     uint8           1-åˆå§‹åŒ–å¤±è´¥ 0-åˆå§‹åŒ–æˆåŠŸ
  759          // ä½¿ç”¨ç¤ºä¾‹     dl1a_init();
  760          // å¤‡æ³¨ä¿¡æ¯     
  761          //-------------------------------------------------------------------------------------------------------
             -------------
  762          uint8 dl1a_init (void)
  763          {
  764   1          uint32 measurement_timing_budget_us = 0;
  765   1          uint8 stop_variable = 0;
  766   1          uint8 return_state = 0;
  767   1          uint8 reg_data_buffer = 0;
  768   1          uint8 ref_spad_map[6];
  769   1          uint8 data_buffer[7];
  770   1        uint8 i = 0;
  771   1        
  772   1          memset(ref_spad_map, 0, 6);
  773   1          memset(data_buffer, 0, 7);
  774   1        
  775   1          do
  776   1          {
  777   2              delay_ms(100);
  778   2              DL1A_XSHUT_PIN = 0;
  779   2              delay_ms(50);
  780   2              DL1A_XSHUT_PIN = 1;
  781   2              delay_ms(100);
  782   2      
  783   2              // -------------------------------- DL1A å¯åŠ¨åˆå§‹åŒ– --------------------------------
  784   2              reg_data_buffer = dl1a_read_register(DL1A_IO_VOLTAGE_CONFIG);         // ä¼ æ„Ÿå™¨é»˜è®¤ IO ä¸º 1
             -.8V æ¨¡å¼
  785   2              dl1a_write_register(DL1A_IO_VOLTAGE_CONFIG, reg_data_buffer | 0x01);  // é…ç½® IO ä¸º 2.8V æ¨¡å¼
             -
  786   2      
  787   2              dl1a_write_register(0x88, 0x00);                                         // è®¾ç½®ä¸ºæ ‡å‡† IIC æ
             -¨¡å¼
  788   2      
  789   2              dl1a_write_register(0x80, 0x01);
  790   2              dl1a_write_register(0xFF, 0x01);
  791   2              dl1a_write_register(0x00, 0x00);
  792   2      
  793   2              dl1a_read_registers(0x91, &stop_variable , 1);
  794   2      
C251 COMPILER V5.60.0,  DL1A                                                               25/04/24  13:33:30  PAGE 14  

  795   2              dl1a_write_register(0x00, 0x01);
  796   2              dl1a_write_register(0xFF, 0x00);
  797   2              dl1a_write_register(0x80, 0x00);
  798   2      
  799   2              // ç¦ç”¨ SIGNAL_RATE_MSRC(bit1) å’Œ SIGNAL_RATE_PRE_RANGE(bit4) é™åˆ¶æ£€æŸ¥
  800   2              reg_data_buffer = dl1a_read_register(DL1A_MSRC_CONFIG);
  801   2              dl1a_write_register(DL1A_MSRC_CONFIG, reg_data_buffer | 0x12);
  802   2      
  803   2              dl1a_set_signal_rate_limit(DL1A_DEFAULT_RATE_LIMIT);                  // è®¾ç½®ä¿¡å·é€Ÿç‡é™åˆ¶
  804   2              dl1a_write_register(DL1A_SYSTEM_SEQUENCE_CONFIG, 0xFF);
  805   2              // -------------------------------- DL1A å¯åŠ¨åˆå§‹åŒ– --------------------------------
  806   2      
  807   2              // -------------------------------- DL1A é…ç½®åˆå§‹åŒ– --------------------------------
  808   2              if (dl1a_get_spad_info(&data_buffer[0], &data_buffer[1]))
  809   2              {
  810   3            return_state = 1;
  811   3                  // å¦‚æœç¨‹åºåœ¨è¾“å‡ºäº†æ–­è¨€ä¿¡æ¯ å¹¶ä¸”æç¤ºå‡ºé”™ä½ç½®åœ¨è¿™é‡Œ
  812   3                  // é‚£ä¹ˆå°±æ˜¯ dl1a è‡ªæ£€å‡ºé”™å¹¶è¶…æ—¶é€€å‡ºäº†
  813   3                  // æ£€æŸ¥ä¸€ä¸‹æ¥çº¿æœ‰æ²¡æœ‰é—®é¢˜ å¦‚æœæ²¡é—®é¢˜å¯èƒ½å°±æ˜¯åäº†
  814   3      
  815   3            printf("dl1a init error.\r\n");
  816   3            break;
  817   3              }
  818   2      
  819   2              // ä» GLOBAL_CONFIG_SPAD_ENABLES_REF_[0-6] è·å– SPAD map (RefGoodSpadMap) æ•°æ®
  820   2              dl1a_read_registers(DL1A_GLOBAL_CONFIG_SPAD_ENABLES_REF_0, ref_spad_map, 6);
  821   2      
  822   2              dl1a_write_register(0xFF, 0x01);
  823   2              dl1a_write_register(DL1A_DYNAMIC_SPAD_REF_EN_START_OFFSET, 0x00);
  824   2              dl1a_write_register(DL1A_DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD, 0x2C);
  825   2              dl1a_write_register(0xFF, 0x00);
  826   2              dl1a_write_register(DL1A_GLOBAL_CONFIG_REF_EN_START_SELECT, 0xB4);
  827   2      
  828   2              data_buffer[2] = data_buffer[1] ? 12 : 0; // 12 is the first aperture spad
  829   2              for (i = 0; i < 48; i++)
  830   2              {
  831   3                  if (i < data_buffer[2] || data_buffer[3] == data_buffer[0])
  832   3                  {
  833   4                      // æ­¤ä½ä½äºåº”å¯ç”¨çš„ç¬¬ä¸€ä¸ªä½
  834   4                      // æˆ–è€… (eference_spad_count) ä½å·²å¯ç”¨
  835   4                      // å› æ­¤æ­¤ä½ä¸ºé›¶
  836   4                      ref_spad_map[i / 8] &= ~(1 << (i % 8));
  837   4                  }
  838   3                  else if ((ref_spad_map[i / 8] >> (i % 8)) & 0x1)
  839   3                  {
  840   4                      data_buffer[3]++;
  841   4                  }
  842   3              }
  843   2      
  844   2              data_buffer[0] = DL1A_GLOBAL_CONFIG_SPAD_ENABLES_REF_0;
  845   2              for(i = 1; i < 7; i++)
  846   2              {
  847   3                  data_buffer[1] = ref_spad_map[i-1];
  848   3              }
  849   2              dl1a_write_array(data_buffer, 7);
  850   2      
  851   2              // é»˜è®¤è½¬æ¢è®¾ç½® version 02/11/2015_v36
  852   2              dl1a_write_register(0xFF, 0x01);
  853   2              dl1a_write_register(0x00, 0x00);
  854   2              dl1a_write_register(0xFF, 0x00);
  855   2              dl1a_write_register(0x09, 0x00);
  856   2              dl1a_write_register(0x10, 0x00);
  857   2              dl1a_write_register(0x11, 0x00);
  858   2              dl1a_write_register(0x24, 0x01);
  859   2              dl1a_write_register(0x25, 0xFF);
  860   2              dl1a_write_register(0x75, 0x00);
C251 COMPILER V5.60.0,  DL1A                                                               25/04/24  13:33:30  PAGE 15  

  861   2              dl1a_write_register(0xFF, 0x01);
  862   2              dl1a_write_register(0x4E, 0x2C);
  863   2              dl1a_write_register(0x48, 0x00);
  864   2              dl1a_write_register(0x30, 0x20);
  865   2              dl1a_write_register(0xFF, 0x00);
  866   2              dl1a_write_register(0x30, 0x09);
  867   2              dl1a_write_register(0x54, 0x00);
  868   2              dl1a_write_register(0x31, 0x04);
  869   2              dl1a_write_register(0x32, 0x03);
  870   2              dl1a_write_register(0x40, 0x83);
  871   2              dl1a_write_register(0x46, 0x25);
  872   2              dl1a_write_register(0x60, 0x00);
  873   2              dl1a_write_register(0x27, 0x00);
  874   2              dl1a_write_register(0x50, 0x06);
  875   2              dl1a_write_register(0x51, 0x00);
  876   2              dl1a_write_register(0x52, 0x96);
  877   2              dl1a_write_register(0x56, 0x08);
  878   2              dl1a_write_register(0x57, 0x30);
  879   2              dl1a_write_register(0x61, 0x00);
  880   2              dl1a_write_register(0x62, 0x00);
  881   2              dl1a_write_register(0x64, 0x00);
  882   2              dl1a_write_register(0x65, 0x00);
  883   2              dl1a_write_register(0x66, 0xA0);
  884   2              dl1a_write_register(0xFF, 0x01);
  885   2              dl1a_write_register(0x22, 0x32);
  886   2              dl1a_write_register(0x47, 0x14);
  887   2              dl1a_write_register(0x49, 0xFF);
  888   2              dl1a_write_register(0x4A, 0x00);
  889   2              dl1a_write_register(0xFF, 0x00);
  890   2              dl1a_write_register(0x7A, 0x0A);
  891   2              dl1a_write_register(0x7B, 0x00);
  892   2              dl1a_write_register(0x78, 0x21);
  893   2              dl1a_write_register(0xFF, 0x01);
  894   2              dl1a_write_register(0x23, 0x34);
  895   2              dl1a_write_register(0x42, 0x00);
  896   2              dl1a_write_register(0x44, 0xFF);
  897   2              dl1a_write_register(0x45, 0x26);
  898   2              dl1a_write_register(0x46, 0x05);
  899   2              dl1a_write_register(0x40, 0x40);
  900   2              dl1a_write_register(0x0E, 0x06);
  901   2              dl1a_write_register(0x20, 0x1A);
  902   2              dl1a_write_register(0x43, 0x40);
  903   2              dl1a_write_register(0xFF, 0x00);
  904   2              dl1a_write_register(0x34, 0x03);
  905   2              dl1a_write_register(0x35, 0x44);
  906   2              dl1a_write_register(0xFF, 0x01);
  907   2              dl1a_write_register(0x31, 0x04);
  908   2              dl1a_write_register(0x4B, 0x09);
  909   2              dl1a_write_register(0x4C, 0x05);
  910   2              dl1a_write_register(0x4D, 0x04);
  911   2              dl1a_write_register(0xFF, 0x00);
  912   2              dl1a_write_register(0x44, 0x00);
  913   2              dl1a_write_register(0x45, 0x20);
  914   2              dl1a_write_register(0x47, 0x08);
  915   2              dl1a_write_register(0x48, 0x28);
  916   2              dl1a_write_register(0x67, 0x00);
  917   2              dl1a_write_register(0x70, 0x04);
  918   2              dl1a_write_register(0x71, 0x01);
  919   2              dl1a_write_register(0x72, 0xFE);
  920   2              dl1a_write_register(0x76, 0x00);
  921   2              dl1a_write_register(0x77, 0x00);
  922   2              dl1a_write_register(0xFF, 0x01);
  923   2              dl1a_write_register(0x0D, 0x01);
  924   2              dl1a_write_register(0xFF, 0x00);
  925   2              dl1a_write_register(0x80, 0x01);
  926   2              dl1a_write_register(0x01, 0xF8);
C251 COMPILER V5.60.0,  DL1A                                                               25/04/24  13:33:30  PAGE 16  

  927   2              dl1a_write_register(0xFF, 0x01);
  928   2              dl1a_write_register(0x8E, 0x01);
  929   2              dl1a_write_register(0x00, 0x01);
  930   2              dl1a_write_register(0xFF, 0x00);
  931   2              dl1a_write_register(0x80, 0x00);
  932   2      
  933   2              // å°†ä¸­æ–­é…ç½®è®¾ç½®ä¸ºæ–°æ ·å“å°±ç»ª
  934   2              dl1a_write_register(DL1A_SYSTEM_INTERRUPT_GPIO_CONFIG, 0x04);
  935   2              reg_data_buffer = dl1a_read_register(DL1A_GPIO_HV_MUX_ACTIVE_HIGH);
  936   2              dl1a_write_register(DL1A_GPIO_HV_MUX_ACTIVE_HIGH, reg_data_buffer & ~0x10);
  937   2              dl1a_write_register(DL1A_SYSTEM_INTERRUPT_CLEAR, 0x01);
  938   2      
  939   2              measurement_timing_budget_us  = dl1a_get_measurement_timing_budget();
  940   2      
  941   2              // é»˜è®¤æƒ…å†µä¸‹ç¦ç”¨ MSRC å’Œ TCC
  942   2              // MSRC = Minimum Signal Rate Check
  943   2              // TCC = Target CentreCheck
  944   2              dl1a_write_register(DL1A_SYSTEM_SEQUENCE_CONFIG, 0xE8);
  945   2              dl1a_set_measurement_timing_budget(measurement_timing_budget_us);    // é‡æ–°è®¡ç®—æ—¶åºé¢„ç®—
  946   2              // -------------------------------- DL1A é…ç½®åˆå§‹åŒ– --------------------------------
  947   2      
  948   2              dl1a_write_register(DL1A_SYSTEM_SEQUENCE_CONFIG, 0x01);
  949   2              if (dl1a_perform_single_ref_calibration(0x40))
  950   2              {
  951   3                  return_state = 1;
  952   3                  break;
  953   3              }
  954   2              dl1a_write_register(DL1A_SYSTEM_SEQUENCE_CONFIG, 0x02);
  955   2              if (dl1a_perform_single_ref_calibration(0x00))
  956   2              {
  957   3                  return_state = 1;
  958   3                  break;
  959   3              }
  960   2              dl1a_write_register(DL1A_SYSTEM_SEQUENCE_CONFIG, 0xE8);           // æ¢å¤ä»¥å‰çš„åºåˆ—é…ç½®
  961   2      
  962   2              delay_ms(100);
  963   2      
  964   2              dl1a_write_register(0x80, 0x01);
  965   2              dl1a_write_register(0xFF, 0x01);
  966   2              dl1a_write_register(0x00, 0x00);
  967   2              dl1a_write_register(0x91, stop_variable);
  968   2              dl1a_write_register(0x00, 0x01);
  969   2              dl1a_write_register(0xFF, 0x00);
  970   2              dl1a_write_register(0x80, 0x00);
  971   2      
  972   2              dl1a_write_register(DL1A_SYSRANGE_START, 0x02);
  973   2          }while(0);
  974   1      
  975   1          return return_state;
  976   1      }
  977          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      3617     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =         3        122
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
C251 COMPILER V5.60.0,  DL1A                                                               25/04/24  13:33:30  PAGE 17  

  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        19     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
