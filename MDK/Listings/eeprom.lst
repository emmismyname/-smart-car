C251 COMPILER V5.60.0,  eeprom                                                             25/04/24  13:33:28  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE eeprom
OBJECT MODULE PLACED IN .\Out_flie\eeprom.obj
COMPILER INVOKED BY: D:\Keil_80251\C251\BIN\C251.EXE ..\LIB\libraries\eeprom.c XSMALL INTR2 BROWSE INCDIR(..\LIB\startup
                    -;..\LIB\libraries;..\LIB\peripheral;..\USER\inc) DEBUG PRINT(.\Listings\eeprom.lst) TABS(2) OBJECT(.\Out_flie\eeprom.obj
                    -) 

stmt  level    source

    1          
    2          /********************************************************************************************************
             -*************
    3           * @file          eeprom
    4           * @date          2024-03-06
    5           * @note    
    6           ********************************************************************************************************
             -************/
    7          
    8          
    9          #include "eeprom.h"
   10          #include "board.h"
   11          #include "intrins.h"
   12          #include "delay.h"
   13          
   14          //-------------------------------------------------------------------------------------------------------
             -------------
   15          //  @brief      EEPROM触发操作，
   16          //  @param      
   17          //  @return     void
   18          //  Sample usage:           内部使用用户无需关心
   19          //-------------------------------------------------------------------------------------------------------
             -------------
   20          void eeprom_trig(void)
   21          {
   22   1          F0 = EA;    //保存全局中断
   23   1          IAP_TRIG = 0x5A;
   24   1          IAP_TRIG = 0xA5;                    //先送5AH，再送A5H到IAP触发寄存器，每次都需要如此
   25   1                                              //送完A5H后，IAP命令立即被触发启动
   26   1                                              //CPU等待IAP完成后，才会继续执行程序。
   27   1          _nop_();   //由于STC32G是多级流水线的指令系统，触发命令后建议加4个NOP，保证IAP_DATA的数据完成准备
   28   1          _nop_();
   29   1          _nop_();
   30   1          _nop_();
   31   1        
   32   1          EA = F0;    //恢复全局中断
   33   1      }
   34          
   35          
   36          //-------------------------------------------------------------------------------------------------------
             -------------
   37          //  @brief      初始化EEPROM
   38          //  @param      NULL
   39          //  @return     void
   40          //  Sample usage:           
   41          //-------------------------------------------------------------------------------------------------------
             -------------
   42          void iap_init(void)
   43          {
   44   1        IAP_CONTR = 0x80;   //使能EEPROM操作
   45   1        iap_set_tps();      //设置擦除等待时间
   46   1      
   47   1        
   48   1      }
   49          
   50          //-------------------------------------------------------------------------------------------------------
             -------------
C251 COMPILER V5.60.0,  eeprom                                                             25/04/24  13:33:28  PAGE 2   

   51          //  @brief      关闭EEPROM
   52          //  @param      NULL
   53          //  @return     void
   54          //  Sample usage:           
   55          //-------------------------------------------------------------------------------------------------------
             -------------
   56          void iap_idle(void)
   57          {
   58   1        IAP_CONTR = 0;      //失能EEPROM操作
   59   1      }
   60          
   61          
   62          //-------------------------------------------------------------------------------------------------------
             -------------
   63          //  @brief      获取EEPROM操作失败状态位，需要软件清零
   64          //  @param      NULL
   65          //  @return     void
   66          //  Sample usage:           
   67          //                操作失败返回1;
   68          //-------------------------------------------------------------------------------------------------------
             -------------
   69          uint8 iap_get_cmd_state(void)
   70          {
   71   1        return ((IAP_CONTR&0x01) == 0x01);
   72   1      }
   73          
   74          
   75          //-------------------------------------------------------------------------------------------------------
             -------------
   76          //  @brief      设置IAP等待时间
   77          //  @param      NULL
   78          //  @return     void
   79          //  Sample usage:           
   80          //-------------------------------------------------------------------------------------------------------
             -------------
   81          void iap_set_tps(void)
   82          {
   83   1        uint8 write_time;
   84   1        write_time = (sys_clk / 1000000) ;
   85   1        IAP_TPS = write_time;
   86   1      }
   87          
   88          
   89          //-------------------------------------------------------------------------------------------------------
             -------------
   90          //  @brief      EEPROM读取多个字节
   91          //  @param      addr      需要读取的eeprom地址
   92          //  @param      *buf      需要读取的数据地址
   93          //  @param      len       需要读取的数据长度
   94          //  @return     void
   95          //  Sample usage:               uint8 str[10];
   96          //                iap_read_bytes(0x00,str,10);
   97          //                将0x00-0x0A地址中的数据，读取到str中。
   98          //-------------------------------------------------------------------------------------------------------
             -------------
   99          void iap_read_bytes(uint32 addr, uint8 *buf, uint16 len)
  100          {
  101   1      
  102   1        
  103   1        IAP_CMD = 1;        //设置 IAP 读命令 
  104   1      
  105   1        while(len--)
  106   1        {
  107   2          IAP_ADDRL = addr;     //设置 IAP 低地址
  108   2          IAP_ADDRH = addr >> 8;  //设置 IAP 高地址
  109   2          IAP_ADDRE = addr >> 16; //设置 IAP 最高地址
C251 COMPILER V5.60.0,  eeprom                                                             25/04/24  13:33:28  PAGE 3   

  110   2              eeprom_trig();
  111   2          *buf++ = IAP_DATA;    //读 IAP 数据
  112   2          addr++;
  113   2          
  114   2        }
  115   1        
  116   1      }
  117          
  118          
  119          //-------------------------------------------------------------------------------------------------------
             -------------
  120          //  @brief      EEPROM写多个字节
  121          //  @param      addr      需要写的eeprom地址
  122          //  @param      *buf      需要写的数据地址
  123          //  @param      len       需要写的数据长度
  124          //  @return     void
  125          //  Sample usage:           iap_write_bytes(0x00,(uint8 *)"0123456789",10);
  126          //                将"0123456789"写入0x00-0x0A地址中;
  127          //-------------------------------------------------------------------------------------------------------
             -------------
  128          void iap_write_bytes(uint32 addr, uint8 *buf, uint16 len)
  129          {
  130   1      
  131   1        IAP_CMD = 2;        //设置 IAP 读命令 
  132   1        
  133   1        while(len--)
  134   1        {
  135   2          IAP_ADDRL = addr;     //设置 IAP 低地址
  136   2          IAP_ADDRH = addr >> 8;  //设置 IAP 高地址
  137   2          IAP_ADDRE = addr >> 16; //设置 IAP 最高地址
  138   2          IAP_DATA = *buf++;    //写 IAP 数据
  139   2          addr++;
  140   2      
  141   2          eeprom_trig();
  142   2        }
  143   1        
  144   1      }
  145          
  146          
  147          
  148          //-------------------------------------------------------------------------------------------------------
             -------------
  149          //  @brief      EEPROM擦除目标地址所在的一页（1扇区/512字节）
  150          //  @param      addr      需要写的eeprom地址
  151          //  @return     void
  152          //  Sample usage:           iap_erase_page(0x20);
  153          //                擦除0x00-0x200的数据
  154          //-------------------------------------------------------------------------------------------------------
             -------------
  155          void iap_erase_page(uint32 addr) 
  156          { 
  157   1      
  158   1        IAP_CMD = 3;        //设置 IAP 擦除命令
  159   1        IAP_ADDRL = addr;       //设置 IAP 低地址
  160   1        IAP_ADDRH = addr >> 8;    //设置 IAP 高地址
  161   1        IAP_ADDRE = addr >> 16;   //设置 IAP 最高地址
  162   1          eeprom_trig();  
  163   1        
  164   1        
  165   1        delay_ms(10);       //擦除1扇区(512字节)：约4-6ms
  166   1      }
  167          
  168          
  169          
  170          ////-----------------------------------------------------------------------------------------------------
             ---------------
C251 COMPILER V5.60.0,  eeprom                                                             25/04/24  13:33:28  PAGE 4   

  171          ////  @brief      扩展EEPROM写多个字节(无需擦除)
  172          ////  @param      addr      需要写的eeprom地址
  173          ////  @param      *buf      需要写的数据地址
  174          ////  @param      len       需要写的数据长度
  175          ////  @return     void
  176          ////  Sample usage:           extern_iap_write_bytes(0x0000,(uint8 *)"0123456789";,10);
  177          ////                将"0123456789"写入0x00-0x0A地址中;
  178          ////  @note：           不要跨扇区使用。
  179          ////                addr地址：0-511为一个扇区,512-1023为一个扇区，1024-1535为一个扇区，依次类推。
  180          ////-----------------------------------------------------------------------------------------------------
             ---------------
  181          //void extern_iap_write_bytes(uint16 addr, uint8 *buf, uint16 len)
  182          //{ 
  183          //  uint8 temp[512];
  184          //  uint16 i;
  185          //  
  186          //  for(i=0; i<512 ;i++)  temp[i] = 0;      //清0
  187          //  iap_read_bytes(addr&0xFE00, temp, 512);     //读取
  188          //  for(i=0; i<len; i++)  temp[(addr&0x1FF) + i] = buf[i];  //改
  189          //  iap_erase_page(addr);             //擦除
  190          //  iap_write_bytes(addr&0xFE00, temp, 512);    //写入
  191          //}
  192          
  193          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       218     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =    ------         12
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
