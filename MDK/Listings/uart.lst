C251 COMPILER V5.60.0,  uart                                                               25/04/24  13:33:28  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE uart
OBJECT MODULE PLACED IN .\Out_flie\uart.obj
COMPILER INVOKED BY: D:\Keil_80251\C251\BIN\C251.EXE ..\LIB\libraries\uart.c XSMALL INTR2 BROWSE INCDIR(..\LIB\startup;.
                    -.\LIB\libraries;..\LIB\peripheral;..\USER\inc) DEBUG PRINT(.\Listings\uart.lst) TABS(2) OBJECT(.\Out_flie\uart.obj) 

stmt  level    source

    1          
    2          /********************************************************************************************************
             -*************
    3           * @file          uart
    4           * @date          2024-03-06
    5           * @note          
    6           ********************************************************************************************************
             -************/
    7          
    8          
    9          #include "uart.h"
   10          #include "board.h"
   11          
   12          uint8 busy[5] = {0};         //接收忙标志位
   13          
   14          
   15          //-------------------------------------------------------------------------------------------------------
             -------------
   16          //  @brief      串口初始化
   17          //  @param      uart_n          串口模块号(USART_1,USART_2,USART_3,USART_4)
   18          //  @param      uart_rx_pin     串口接收引脚
   19          //  @param      uart_tx_pin     串口发送引脚
   20          //  @param      baud          串口波特率
   21          //  @param      tim_n         使用tim_n作为串口波特率发生器(TIM1-TIM4)
   22          //  @return     NULL            
   23          //  Sample usage:               uart_init(UART_1, UART1_RX_P30, UART1_TX_P31, 115200, TIM_2);        //初
             -始化串口1 波特率115200 发送引脚使用P31 接收引脚使用P30 ,使用定时器2作为波特率发生器
   24          //  @note                       串口1使用 定时器1或者定时器2 作为波特率发生器。
   25          //                串口2使用 定时器2        作为波特率发生器。
   26          //                串口3使用 定时器3或者定时器2 作为波特率发生器。
   27          //                串口4使用 定时器4或者定时器2 作为波特率发生器。
   28          //                              STC32G仅有 定时器0-定时器4，这5个定时器。
   29          //                编码器采集数据也需要定时器作为外部计数。
   30          //                如果不同的串口，使用同一个定时器，串口的波特率以最后一个初始化为准
   31          //-------------------------------------------------------------------------------------------------------
             -------------
   32          void uart_init(UARTN_enum uart_n, UARTPIN_enum uart_rx_pin, UARTPIN_enum uart_tx_pin, uint32 baud, TIMN_e
             -num tim_n)
   33          {
   34   1          uint16 brt;
   35   1      
   36   1        brt = (uint16)(65536 - (sys_clk/baud/4));
   37   1      
   38   1        switch(uart_n)
   39   1        {
   40   2          case UART_1:
   41   2          {
   42   3            if(TIM_1 == tim_n)
   43   3            {
   44   4              SCON |= 0x50;
   45   4              TMOD |= 0x00;
   46   4              TL1 = brt;
   47   4              TH1 = brt >> 8;
   48   4              AUXR |= 0x40;
   49   4              TR1 = 1;
   50   4              busy[1] = 0;
   51   4            }
   52   3            else if(TIM_2 == tim_n)
C251 COMPILER V5.60.0,  uart                                                               25/04/24  13:33:28  PAGE 2   

   53   3            {
   54   4              SCON |= 0x50;
   55   4              T2L = brt;
   56   4              T2H = brt >> 8;
   57   4              AUXR |= 0x15;
   58   4            }
   59   3            P_SW1 &= ~(0x03<<6);
   60   3            if((UART1_RX_P30 == uart_rx_pin) && (UART1_TX_P31 == uart_tx_pin))
   61   3            {
   62   4              P_SW1 |= 0x00;
   63   4            }
   64   3            else if((UART1_RX_P36 == uart_rx_pin) && (UART1_TX_P37 == uart_tx_pin))
   65   3            {
   66   4              P_SW1 |= 0x40;
   67   4            }
   68   3            else if((UART1_RX_P16 == uart_rx_pin) && (UART1_TX_P17 == uart_tx_pin))
   69   3            {
   70   4              P_SW1 |= 0x80;
   71   4            }
   72   3            else if((UART1_RX_P43 == uart_rx_pin) && (UART1_TX_P44 == uart_tx_pin))
   73   3            {
   74   4              P_SW1 |= 0xc0;
   75   4            }
   76   3            busy[1] = 0;
   77   3            ES = 1;
   78   3            break;
   79   3          }
   80   2          
   81   2          case UART_2:
   82   2          {
   83   3            if(TIM_2 == tim_n)
   84   3            {
   85   4              S2CON |= 0x50;
   86   4              T2L = brt;
   87   4              T2H = brt >> 8;
   88   4              AUXR |= 0x14;
   89   4            }
   90   3            
   91   3            P_SW2 &= ~(0x01<<0);
   92   3            if((UART2_RX_P10 == uart_rx_pin) && (UART2_TX_P11 == uart_tx_pin))
   93   3            {
   94   4              P_SW2 |= 0x00;
   95   4            }
   96   3            else if((UART2_RX_P46 == uart_rx_pin) && (UART2_TX_P47 == uart_tx_pin))
   97   3            {
   98   4              P_SW2 |= 0x01;
   99   4            }
  100   3            
  101   3            IE2 |= 0x01 << 0; //允许串行口2中断
  102   3            busy[2] = 0;
  103   3            break;
  104   3          }
  105   2          
  106   2          case UART_3:
  107   2          {
  108   3            if(TIM_2 == tim_n)
  109   3            {
  110   4              S3CON |= 0x10;
  111   4              T2L = brt;
  112   4              T2H = brt >> 8;
  113   4              AUXR |= 0x14;
  114   4            }
  115   3            else if(TIM_3 == tim_n)
  116   3            {
  117   4              S3CON |= 0x50;
  118   4              T3L = brt;
C251 COMPILER V5.60.0,  uart                                                               25/04/24  13:33:28  PAGE 3   

  119   4              T3H = brt >> 8;
  120   4              T4T3M |= 0x0a;
  121   4            }
  122   3            
  123   3            P_SW2 &= ~(0x01<<1);
  124   3            if((UART3_RX_P00 == uart_rx_pin) && (UART3_TX_P01 == uart_tx_pin))
  125   3            {
  126   4              P_SW2 |= 0x00;
  127   4            }
  128   3            else if((UART3_RX_P50 == uart_rx_pin) && (UART3_TX_P51 == uart_tx_pin))
  129   3            {
  130   4              P_SW2 |= 0x02;
  131   4            }
  132   3            
  133   3            IE2 |= 0x01<<3; //允许串行口3中断
  134   3            busy[3] = 0;
  135   3            break;
  136   3          }
  137   2          
  138   2          case UART_4:
  139   2          {
  140   3            if(TIM_2 == tim_n)
  141   3            {
  142   4              S4CON |= 0x10;
  143   4              T2L = brt;
  144   4              T2H = brt >> 8;
  145   4              AUXR = 0x15;
  146   4            }
  147   3            else if(TIM_4 == tim_n)
  148   3            {
  149   4              S4CON |= 0x50;
  150   4              T4L = brt;
  151   4              T4H = brt >> 8;
  152   4              T4T3M |= 0xa0;
  153   4            }
  154   3      
  155   3            P_SW2 &= ~(0x01<<2);
  156   3            if((UART4_RX_P02 == uart_rx_pin) && (UART4_TX_P03 == uart_tx_pin))
  157   3            {
  158   4              P_SW2 |= 0x00;
  159   4            }
  160   3            else if((UART4_RX_P52 == uart_rx_pin) && (UART4_TX_P53 == uart_tx_pin))
  161   3            {
  162   4              P5M0 = 0x00;
  163   4              P5M1 = 0x01<<2;//P5.2 需要设置为高阻
  164   4              P_SW2 |= 0x04;
  165   4            }
  166   3            IE2 |= 0x01<<4; //允许串行口4中断
  167   3            busy[4] = 0;
  168   3            break;
  169   3          }
  170   2          
  171   2        }
  172   1      
  173   1      }
  174          
  175          //-------------------------------------------------------------------------------------------------------
             -------------
  176          //  @brief      串口字节输出
  177          //  @param      uart_n          串口模块号(USART_1,USART_2,USART_3,USART_4)
  178          //  @param      dat             需要发送的字节
  179          //  @return     void        
  180          //  Sample usage:               uart_putchar(UART_1,0xA5);       // 串口1发送0xA5
  181          //-------------------------------------------------------------------------------------------------------
             -------------
  182          void uart_putchar(UARTN_enum uart_n,uint8 dat)
C251 COMPILER V5.60.0,  uart                                                               25/04/24  13:33:28  PAGE 4   

  183          {
  184   1        switch(uart_n)
  185   1        {
  186   2          case UART_1:
  187   2            while (busy[1]);
  188   2            busy[1] = 1;
  189   2            SBUF = dat;
  190   2              break;
  191   2          case UART_2:
  192   2            while (busy[2]);
  193   2            busy[2] = 1;
  194   2            S2BUF = dat;
  195   2              break;
  196   2          case UART_3:
  197   2            while (busy[3]);
  198   2            busy[3] = 1;
  199   2            S3BUF = dat;
  200   2              break;
  201   2          case UART_4:
  202   2            while (busy[4]);
  203   2            busy[4] = 1;
  204   2            S4BUF = dat;
  205   2              break;
  206   2        }
  207   1      }
  208          
  209          
  210          //-------------------------------------------------------------------------------------------------------
             -------------
  211          //  @brief      串口发送数组
  212          //  @param      uart_n          串口模块号(USART_1,USART_2,USART_3,USART_4)
  213          //  @param      *buff           要发送的数组地址
  214          //  @param      len             发送长度
  215          //  @return     void
  216          //  Sample usage:               uart_putbuff(UART_1,&a[0],5);
  217          //-------------------------------------------------------------------------------------------------------
             -------------
  218          void uart_putbuff(UARTN_enum uart_n,uint8 *p,uint32 len)
  219          {
  220   1          while(len--)
  221   1              uart_putchar(uart_n,*p++);
  222   1      }
  223          
  224          
  225          //-------------------------------------------------------------------------------------------------------
             -------------
  226          //  @brief      串口发送字符串
  227          //  @param      uart_n          串口模块号(USART_1,USART_2,USART_3,USART_4)
  228          //  @param      *str            要发送的字符串地址
  229          //  @return     void
  230          //  Sample usage:               uart_putstr(UART_1,"i lvoe you"); 
  231          //-------------------------------------------------------------------------------------------------------
             -------------
  232          void uart_putstr(UARTN_enum uart_n,uint8 *str)
  233          {
  234   1          while(*str)
  235   1          {
  236   2              uart_putchar(uart_n, *str++);
  237   2          }
  238   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       602     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
C251 COMPILER V5.60.0,  uart                                                               25/04/24  13:33:28  PAGE 5   

  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =         5         14
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =         9     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
